mount : 컴포넌트가 처음 나타났을 때
unmount : 컴포넌트가 사라질 때
update : 특정 props값이 바뀔 때

---

- useEffect란?

예시)
useEffect(() => {
console.log("컴포넌트가 화면에 나타남!");
return () => {
console.log("컴포넌트가 화면에서 사라짐!");
};
}, []);

- useEffect(함수, [배열(deps)])

  > > useEffect를 사용할 때, 첫번째 인자(effect)는 함수, 두번째 인자는 배열(deps).

  -. deps에 빈 배열([]): 처음에만 정의된 함수 호출
  -. deps에 의존값 존재 ([deps]): 처음과 지정값이 변경될 때 호출
  -. deps가 아예 없는 경우 (): 컴포넌트가 리렌더링 될 때마다 호출

\*\* useEffect 안에서 사용하는 상태나, props가 있다면, useEffect의 deps에 넣어주어야 함.
넣지 않는다면, useEffect에 등록한 함수가 실행될 때 최신 props상태를 가르키지 않게 됨.

useEffect에서 함수를 반환할 수 있는데 이를 'cleanup'함수라고 함.
'cleanup'함수는 useEffect에 대한 뒷정리를 함. deps가 비어있는 경우에는 컴포넌트가 사라질 때 'cleanup'함수가 호출됨.

---

- useMemo란?

* 성능 최적화 시 사용
* memo는 memorized의 약자이다. (이전에 계산 한 값을 재사용)
* 첫번째 인수에는 파라미터 함수, 두번째 인수에는 deps 배열(변경X-> 이전에 연산한 값을 재사용)을 넣어주면 된다.
  두번째 인수에 넣어준 배열의 값이 바뀔때만 함수가 실행된다.
  그렇지 않다면 이전의 값을 재사용한다.

---

- useCallback이란?
  : useMemo는 '특정 결과 값'을 재사용할 때 사용하는 반면, useCallback은 '특정 함수'를 새로 만들지 않고 재사용하고 싶을 때 사용.

- 주의 \* 함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, deps 배열안에 포함시켜야 함. deps 배열 안에 함수에서 사용하는 값을 넣지 않게 된다면, 함수 내에서 해당 값들을 참조할때 가장 최신 값을 참조 할 것이라고 보장 할 수 없음.

---

- React.memo
  : 컴포넌트의 props가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해주는 함수
  컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 설정할 수 있음.
